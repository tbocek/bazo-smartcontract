\chapter{Evaluation}
This chapter covers the evaluation of the work by describing the implementation of a smaller tokenization contract in order to show an example of the possible functionality and by providing the implementation of a modular exponentiation contract. The modular exponent contract is set in comparison with a golang native implementation in order to show the overhead created by the execution of the logic on the Bazo VM. 




This Chapter covers the evaluation of the Bazo Blockchain as platform for decentralized application with its competitors. The success of a blockchain is mainly influenced by two factors. One of the factors is capabilities and the other factor is performance. 

\section{Contracts}
To compare the smart contract features of the Bazo Blockchain  with other common smart contract platforms, two different smart contracts have been implemented. The goal of the first smart contract is to show the capabilities of the Bazo Blockchain. The second smart contract measures the performance of execution.

\section{Tokenization Contract}
Tokenization is the process of recording the rights to an asset as a digital token on a blockchain in the form of sub-currencies. \cite{eth_whitepaper} Tokenization is the first use-case for smart contracts that has found wide application. New possibilities for funding start-ups and companies have emerged in the form of initial coin offerings (ICOs) also known as token sales. The tokens of an ICO can be bought by sending money in the form of the blockchain currency to a smart contract. The investor then receives corresponding amount in tokens. Ideally, the token is an integral component within the ecosystem of the company hosting the ICO. \cite{ico_pwc} Since tokenization contracts have become so widely used and because they are generally simple, since they do not need to interact with off-chain data, it was decided to write a tokenization contract. In the very basic implementation, a tokenization contract consists of a map of account addresses and balances and methods to transfer those tokens from one account to another.

 \begin{minted}	[
frame=lines,
framesep=2mm,
baselinestretch=1.2,
fontsize=\footnotesize,
linenos
]
{tasm}
CALLDATA
# ------- ABI -------------------------
DUP
PUSH 1
EQ
CALLIF mint 3
HALT

# ------ Contract ---------------------
mint:
LOAD 1 # load value
LOAD 0 # load key
SLOAD 1 # load address of minter
CALLER
EQ
CALLIF adjustBalance 2
RET

adjustBalance:
LOAD 1 # load value
LOAD 0 # load key
DUP
SLOAD 2 # load map
MAPHASKEY
CALLIF addKeyIfNotExists 2
LOAD 1 # load value
LOAD 0 # load key
SLOAD 2 # load map
MAPPUSH
SSTORE 2 # store the map
HALT

addKeyIfNotExists:
LOAD 1 # load key
SLOAD 2 # load map
MAPGETVAL
LOAD 0 # load value
ADD
LOAD 1 # load key
SLOAD 2  # load map
MAPSETVAL
SSTORE 2 # store the map
HALT
\end{minted}

\subsection{Benchmarking Contract}
The performance of the virtual machine is crucial for the speed of execution and the blockchain in general. For this reason a smart contract has been developed which is suitable for comparing the speed of execution on different implementations and platforms. Taking into accord that blockchains and its use-cases depend heavily on public-key cryptographic, it was decided to implement a smart contract which performs modular exponentiation. Modular exponentiation is a one-way function and frequently used in cryptography. Figure \ref{mod_exp_direct} shows the straightforward method to calculate \textit{c}. 

\begin{figure}[thp]%
    	\centering
		$
		c\quad \equiv \quad { b }^{ e }\quad mod\quad m
		$
		\caption{Modular exponentiation straightforward method}
		\label{mod_exp_direct}
\end{figure}

Considering \textit{b} is at least 256 bits for strong cryptography, this method is not very efficient. Therefore, a more memory efficient method has been implemented, which is shown in figure \ref{modularPow_pseudocode}. The benchmarking contract has been implemented in solidity, as a Go program and in Bazo Byte code. The main goal is to compare the overhead.

\begin{figure}[thp]%
    	\centering
		\begin{minipage}{0.7\textwidth}
		\begin{minted}
		[
		frame=lines,
		autogobble,
		framesep=2mm,
		baselinestretch=1.2,
		fontsize=\footnotesize,
		linenos
		]{python}
function modular_pow(base, exponent, modulus)
    if modulus = 1 then return 0 
    c := 1
    for e_prime = 0 to exponent-1
        c := (c * base) mod modulus
    return c
		\end{minted}
		\caption{Memory efficient method to compute modular exponentiation}
		\label{modularPow_pseudocode}
		\end{minipage}
\end{figure}

\section{Results}
\subsection{Tokenization}
% TODO add results of tokenization contract

\subsection{Benchmarks}
The Go testing package contains a subset of functions to measure the performance of Go code. A benchmark function runs the code \textit{b.N} times. \textit{b.N} is adjusted during execution, until the the benchmark function can be timed reliably. \cite{golang_testing}











